<!DOCTYPE html>
<html lang="en">
<%- include('components/head') %>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <body class="bg-neutral-950 text-gray-300 font-[Figtree] min-h-screen flex">

    <!-- Sidebar -->
    <%- include('components/sidebar.ejs') %>

      <!-- Main Content -->
      <div class="flex-1 flex flex-col">

        <!-- Navbar -->
        <%- include('components/nav.ejs') %>

          <!-- VPS Dashboard -->
          <main class="p-6 flex flex-col space-y-6">
            <%- include('components/vpsnav.ejs') %>
              <div class="flex items-center gap-3 ml-auto">
                <button id="btn-start"
                  class="flex items-center gap-2 px-3 py-1.5 bg-emerald-600 text-white text-sm rounded-xl hover:bg-emerald-700 font-semibold shadow-sm transition disabled:opacity-50">
                  <i data-lucide="play" class="w-4 h-4"></i>
                  Start
                </button>
                <button id="btn-stop"
                  class="flex items-center gap-2 px-3 py-1.5 bg-red-600 text-white text-sm rounded-xl hover:bg-red-700 font-semibold shadow-sm transition disabled:opacity-50">
                  <i data-lucide="square" class="w-4 h-4"></i>
                  Stop
                </button>
                <button id="btn-restart"
                  class="flex items-center gap-2 px-3 py-1.5 bg-yellow-500 text-white text-sm rounded-xl hover:bg-yellow-600 font-semibold shadow-sm transition disabled:opacity-50">
                  <i data-lucide="refresh-ccw" class="w-4 h-4"></i>
                  Restart
                </button>
              </div>

      </div>

      <!-- VPS Info -->
      <div class="bg-neutral-950 p-6 rounded-2xl shadow-lg border border-[#2a2a2a] flex flex-col space-y-4">
        <h1 class="text-3xl font-bold text-gray-200">
          <%= server.name || "Unnamed VPS" %>
        </h1>

        <div class="flex items-center space-x-2 text-sm md:text-base">
          <% if (server.ssh.includes('https')) { %>
            <span class="font-semibold">Access:</span>
            <% } else { %>
              <span class="font-semibold">SSH:</span>
              <% } %>
                <% if (server.ssh) { %>
                  <% if (server.ssh.includes('https')) { %>
                    <a href="<%= server.ssh %>" target="_blank"
                      class="px-3 py-1 bg-neutral-900 rounded text-blue-400 font-mono whitespace-nowrap hover:underline">
                      <%= server.ssh %>
                    </a>
                    <% } else { %>
                      <span class="px-3 py-1 bg-neutral-900 rounded text-green-400 font-mono whitespace-nowrap">
                        <%= server.ssh %>
                      </span>
                      <% } %>
                        <% } else { %>
                          <span class="px-3 py-1 bg-neutral-700 rounded text-gray-500 italic">N/A</span>
                          <% } %>
        </div>

        <!-- Uptime -->
        <div class="flex items-center space-x-2 text-sm md:text-base">
          <span class="font-semibold">Uptime:</span>
          <span id="uptime-display" class="px-3 py-1 bg-neutral-900 rounded text-blue-400 font-mono whitespace-nowrap">
            Loading...
          </span>
        </div>

        <!-- Status -->
        <div class="flex items-center space-x-2 text-sm md:text-base">
          <span class="font-semibold">Status:</span>
          <span id="vps-status" class="px-4 py-2 rounded-xl font-semibold text-sm bg-gray-500 text-white">
            Loading
          </span>
        </div>
      </div>
      <!-- Logs + Exec Panel -->
      <div class="bg-neutral-950 p-6 rounded-2xl shadow-lg border border-[#2a2a2a] flex flex-col space-y-4">
        <!-- Logs -->
        <div>
          <h3 class="text-lg font-semibold text-gray-200 mb-2">Logs</h3>
          <div id="logContainer"
            class="bg-neutral-950 border border-[#2a2a2a] rounded-lg p-3 h-60 overflow-y-auto font-mono text-sm space-y-1">
          </div>
        </div>

        <!-- Exec -->
        <div class="flex gap-2">
          <input id="execInput" type="text" placeholder="Type command..."
            class="flex-1 px-3 py-2 rounded-lg bg-neutral-900 text-gray-200 font-mono text-sm outline-none border border-[#2a2a2a]" />
          <button id="execBtn"
            class="px-4 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-500 text-white text-sm">Run</button>
        </div>
      </div>

      <!-- Charts -->
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <!-- CPU -->
        <div class="bg-neutral-950 rounded-2xl p-6 shadow-lg border border-[#2a2a2a]">
          <h2 class="text-xl font-semibold text-gray-200 mb-4">CPU Usage</h2>
          <canvas id="cpuChart" class="w-full h-64"></canvas>
        </div>

        <!-- RAM -->
        <div class="bg-neutral-950 rounded-2xl p-6 shadow-lg border border-[#2a2a2a]">
          <h2 class="text-xl font-semibold text-gray-200 mb-4">RAM Usage</h2>
          <canvas id="ramChart" class="w-full h-64"></canvas>
        </div>

        <!-- Disk -->
        <div class="bg-neutral-950 rounded-2xl p-6 shadow-lg border border-[#2a2a2a]">
          <h2 class="text-xl font-semibold text-gray-200 mb-4">Disk Usage</h2>
          <canvas id="diskChart" class="w-full h-64"></canvas>
        </div>
        <!-- Network -->
        <div class="bg-neutral-950 rounded-2xl p-6 shadow-lg border border-[#2a2a2a]">
          <h2 class="text-xl font-semibold text-gray-200 mb-4">Network Usage</h2>
          <canvas id="networkChart" class="w-full h-64"></canvas>
        </div>

      </div>
      <%- include('components/footer.ejs') %>
        </main>
        </div>

        <script>
          const containerId = "<%= server.containerId %>";

          // Chart.js base options
          const baseOptions = {
            responsive: true,
            animation: false,
            plugins: {
              legend: { display: false },
              title: { display: false },
              tooltip: {
                enabled: true,
                backgroundColor: "rgb(23,23,23)",
                titleColor: "#e5e7eb",
                bodyColor: "#d1d5db",
                borderColor: "#2a2a2a",
                borderWidth: 1,
                displayColors: false,
                callbacks: {
                  title: () => null,
                  label: (context) => {
                    let lines = [];
                    if (context.dataset.label) {
                      lines.push(`${context.dataset.label}: ${context.formattedValue}`);
                    } else {
                      const parsed = context.parsed;
                      for (const key in parsed) {
                        lines.push(`${key}: ${parsed[key]}`);
                      }
                    }
                    return lines;
                  },
                },
              },
            },
            layout: { padding: 0 },
            scales: {
              x: {
                min: 0,
                max: 19,
                type: "linear",
                grid: { display: false, drawBorder: false },
                ticks: { display: false },
              },
              y: {
                min: 0,
                type: "linear",
                grid: {
                  display: true,
                  color: getTailwindColor("gray", 700),
                  drawBorder: false,
                },
                ticks: {
                  display: true,
                  count: 3,
                  color: getTailwindColor("gray", 200),
                  font: {
                    family: "'Figtree', sans-serif",
                    size: 11,
                    weight: "400",
                  },
                },
              },
            },
            elements: {
              point: { radius: 0, hitRadius: 20 },
              line: { tension: 0.15 },
            },
          };

          function getTailwindColor(color, shade) {
            const colors = {
              gray: { 200: "#e5e7eb", 700: "#374151" },
            };
            return colors[color]?.[shade] || "#ccc";
          }

          const labels = Array.from({ length: 20 }, (_, i) => i);

          // Chart datasets
          const cpuData = {
            labels,
            datasets: [
              {
                label: "CPU %",
                data: Array(20).fill(0),
                borderColor: "rgb(34,197,94)",
                backgroundColor: "rgba(34,197,94,0.2)",
                tension: 0.3,
              },
            ],
          };
          const ramData = {
            labels,
            datasets: [
              {
                label: "RAM MB",
                data: Array(20).fill(0),
                borderColor: "rgb(59,130,246)",
                backgroundColor: "rgba(59,130,246,0.2)",
                tension: 0.3,
              },
            ],
          };
          const diskData = {
            labels,
            datasets: [
              {
                label: "Disk MB",
                data: Array(20).fill(0),
                borderColor: "rgb(245,158,11)",
                backgroundColor: "rgba(245,158,11,0.2)",
                tension: 0.3,
              },
            ],
          };
          const networkData = {
            labels,
            datasets: [
              {
                label: "Inbound MB",
                data: Array(20).fill(0),
                borderColor: "rgb(59,130,246)",
                backgroundColor: "rgba(59,130,246,0.2)",
                tension: 0.3,
              },
              {
                label: "Outbound MB",
                data: Array(20).fill(0),
                borderColor: "rgb(168,85,247)",
                backgroundColor: "rgba(168,85,247,0.2)",
                tension: 0.3,
              },
            ],
          };

          // Initialize charts
          const cpuChart = new Chart(document.getElementById("cpuChart"), {
            type: "line",
            data: cpuData,
            options: baseOptions,
          });
          const ramChart = new Chart(document.getElementById("ramChart"), {
            type: "line",
            data: ramData,
            options: baseOptions,
          });
          const diskChart = new Chart(document.getElementById("diskChart"), {
            type: "line",
            data: diskData,
            options: baseOptions,
          });
          const networkChart = new Chart(document.getElementById("networkChart"), {
            type: "line",
            data: networkData,
            options: baseOptions,
          });

// --- Buttons ---
<% if (server.ssh.includes('https')) { %>
const btnRessh = document.getElementById("btn-ressh");
<% } %>
const btnStart = document.getElementById("btn-start");
          const btnStop = document.getElementById("btn-stop");
          const btnRestart = document.getElementById("btn-restart");

          // --- Logs ---
          const logContainer = document.getElementById("logContainer");
          const logColors = {
            INFO: "#d4d4d4",
            DOCKER: "#0000FF",
            ACTION: "#38bdf8",
            ERROR: "#ef4444",
            SUCCESS: "#10b981",
          };
         function cleanLine(line) {
            let stripped = stripAnsiAndOsc(line);

            // Handle carriage returns (\r) by keeping only the last portion
            if (stripped.includes("\r")) {
              const parts = stripped.split("\r");
              stripped = parts[parts.length - 1];
            }

            // Remove prompt lines
            if (/root@.+:.*#/.test(stripped.trim())) return "root@<%= server.name %>~$ ";

            return stripped.trim();
          }

             function stripAnsiAndOsc(str) {
              return str
                // Remove ANSI escape codes
                .replace(/\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])/g, "")
                // Remove OSC (like ]0;... BEL)
                .replace(/\x1b\][^\x07]*(\x07|\x1b\\)/g, "")
                // Remove stray control characters
                .replace(/[\x00-\x1F\x7F]/g, "");
            }
          function addLog(type, message) {
  const cleanMessage = cleanLine(message);
  if (!cleanMessage) return; // skip empty/garbage lines

  // Check if the message has a carriage return (\r)
  const isProgressLine = message.includes("\r");

  let line;
  if (isProgressLine && logContainer.lastChild) {
    // Update the last line instead of adding a new one
    line = logContainer.lastChild;
    line.querySelector("span:last-child").previousSibling.textContent = cleanMessage;
  } else {
    line = document.createElement("div");
    line.classList.add(
      "flex",
      "items-center",
      "gap-2",
      "hover:bg-neutral-900",
      "transition",
      "rounded-md",
      "px-2", "py-1",
      "w-full",
      "font-[Figtree]"
    );

    const badge = document.createElement("span");
    badge.textContent = type;
    badge.className = "px-2 py-0.5 text-xs font-[Figtree] uppercase rounded";
    badge.style.color = logColors[type] || "#d4d4d4";
    badge.style.backgroundColor = hexToAlpha(logColors[type] || "#d4d4d4", 0.1);

    const text = document.createElement("span");
    text.textContent = cleanMessage;

    const rightSide = document.createElement("div");
    rightSide.classList.add("flex", "items-center", "gap-1", "ml-auto");

    const icon = document.createElement("i");
    icon.setAttribute("data-lucide", "router");
    icon.className = "w-3 h-3 text-neutral-500";

    const timestamp = document.createElement("span");
    timestamp.textContent = new Date().toLocaleTimeString();
    timestamp.className = "text-xs text-gray-500 font-[Figtree]";

    rightSide.appendChild(icon);
    rightSide.appendChild(timestamp);

    line.appendChild(badge);
    line.appendChild(text);
    line.appendChild(rightSide);

    logContainer.appendChild(line);

    if (window.lucide) {
      lucide.createIcons();
    }
  }

  logContainer.scrollTop = logContainer.scrollHeight;
}



          function hexToAlpha(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r},${g},${b},${alpha})`;
          }

          // --- Button states ---
          function updateActionButtons(status) {
            btnStart.disabled = true;
            btnStop.disabled = true;
            btnRestart.disabled = true;

            if (status === "running") {
              btnStop.disabled = false;
              btnRestart.disabled = false;
            } else if (status === "exited") {
              btnStart.disabled = false;
            }
          }

          let isconnectedtodaemon = false;
          let wasfailed = false;
          async function updateVPS() {
            try {
              const res = await fetch(`/server/stats/${containerId}`);
              const data = await res.json();
              if (!isconnectedtodaemon && res.ok) {
                isconnectedtodaemon = true;
                addLog('SUCCESS', "Connected to the Daemon");
              } else if (!isconnectedtodaemon && !wasfailed && !res.ok) {
                wasfailed = true
                showPopup("error", "Connection Failed", "Failed to connect to the Daemon")
                addLog('ERROR', "Failed to Connect to the daemon is the Node Offline?");
              }
              // Status
              const statusEl = document.getElementById("vps-status");
              let bgClass;
              let statusfromres;
              switch (data.status) {
                case "running":
                  bgClass = "bg-green-500";
                  statusfromres = "Running";
                  break;
                case "exited":
                  bgClass = "bg-red-500";
                  statusfromres = "Stopped";
                  break;
                case "node missing":
                  bgClass = "bg-yellow-500";
                  statusfromres = "Node Missing";
                  break;
                case "error":
                  bgClass = "bg-orange-500";
                  statusfromres = "Error";
                  break;
                default:
                  bgClass = "bg-gray-500";
              }
              statusEl.textContent = statusfromres || "unknown";
              statusEl.className = `px-4 py-2 rounded-xl font-semibold text-sm text-white ${bgClass}`;
              // Uptime
              document.getElementById("uptime-display").textContent =
                data.uptime || "N/A";

              // Buttons
              updateActionButtons(data.status);

              // Push chart data
              function pushData(chart, values) {
                if (!Array.isArray(values)) values = [values];
                values.forEach((val, i) => {
                  chart.data.datasets[i].data.push(val);
                  chart.data.datasets[i].data.shift();
                });
                chart.update();
              }
              pushData(cpuChart, data.cpuPercent ?? 0);
              pushData(ramChart, data.memoryMB ?? 0);
              pushData(networkChart, [
                data.network?.inboundKB ?? 0 / 1024,
                data.network?.outboundKB ?? 0 / 1024,
              ]);
              pushData(diskChart, data.diskUsageMB ?? 0);
            } catch (err) {
              isconnectedtodaemon = false;
              console.error("Failed to fetch VPS stats:", err);
            }
          }
          addLog("INFO", "Connecting to the daemon");
          updateVPS();
          setInterval(updateVPS, 2000);

// --- Ressh ---
<% if (server.ssh.includes('https')) { %>
            btnRessh.addEventListener("click", async () => {
              addLog("ACTION", "Fetching SSH session...");
              btnRessh.disabled = true;
              btnRessh.textContent = "Fetching SSH...";
              try {
                const res = await fetch(`/vps/ressh/${containerId}`, { method: "POST" });
                await res.text();
                addLog("SUCCESS", "SSH session refreshed.");
                window.location.reload();
              } catch (err) {
                addLog("ERROR", "Failed to fetch SSH info.");
                console.error("Ressh fetch error:", err);
              } finally {
                btnRessh.disabled = false;
                btnRessh.textContent = "Ressh";
              }
            });
<% } %>

            // --- Start/Stop/Restart ---
            async function performAction(action) {
              let actiontorun = action;
              try {
                if (actiontorun === "stop") {
                  actiontorun = `Stopp`
                } else if (actiontorun === "start") {
                  actiontorun = `Start`
                } else if (actiontorun === "restart") {
                  actiontorun = `Restart`
                }
              } catch (err) {
                console.log(err)
                addLog("ERROR", `Failed to ${action} vps`);
              }
              addLog("ACTION", `${actiontorun}ing VPS...`);
              try {
                const res = await fetch(`/vps/action/${containerId}/${action}`, {
                  method: "POST",
                });
                const data = await res.json();
                addLog("SUCCESS", `${actiontorun}` + 'ed' + ` successfully`);
              } catch (err) {
                console.error(err);
                addLog("ERROR", `Failed to ${action} vps`);
              }
            }
          btnStart.addEventListener("click", () => performAction("start"));
          btnStop.addEventListener("click", () => performAction("stop"));
          btnRestart.addEventListener("click", () => performAction("restart"));

          let attachedId = null;
          let logInterval = null;

          // Create attach session automatically
          async function attachSession() {
            const res = await fetch(`/vps/${containerId}/attach`, { method: "POST" });
            const data = await res.json();
            attachedId = data.attachedId;

            if (attachedId) {
              startLogPolling();
            }
          }
          function startLogPolling() {
            let pendingLogs = [];
            let renderInterval;
            const seenLines = new Set(); // store all lines we've already shown

            logInterval = setInterval(async () => {
              try {
                const res = await fetch(`/vps/${containerId}/attached/${attachedId}/logs`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({})
                });

                if (!res.ok) {
                  clearInterval(logInterval);
                  clearInterval(renderInterval);
                  return;
                }

                const data = await res.json();
                if (data.logs) {
                  const lines = data.logs.split("\n").filter(l => l.trim() !== "");

                  lines.forEach(line => {
                    const fixline = cleanLine(line);
                    if (!seenLines.has(fixline)) {
                      pendingLogs.push(fixline);
                      seenLines.add(fixline);
                    }
                  });
                }
              } catch (err) {
                console.error("Log polling stopped:", err);
                clearInterval(logInterval);
                clearInterval(renderInterval);
              }
            }, 2000);

            // Render slowly in chunks
            renderInterval = setInterval(() => {
              if (pendingLogs.length > 0) {
                const chunk = pendingLogs.splice(0, 5); // show 5 at a time
                chunk.forEach(line => addLog("DOCKER", line));

                const logContainer = document.getElementById("logContainer");
                logContainer.scrollTop = logContainer.scrollHeight;
              }
            }, 200);
          }

          document.getElementById("execBtn").addEventListener("click", async () => {
            const cmd = document.getElementById("execInput").value.trim();
            if (!cmd || !attachedId) return;
            if (cmd === 'exit') {
              performAction("stop");
              document.getElementById("execInput").value = "";
              return;
            }
            await fetch(`/vps/${containerId}/attached/${attachedId}/execute`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ command: cmd })
            });
            document.getElementById("execInput").value = "";
          });
          attachSession();
          lucide.createIcons();
        </script>
  </body>

</html>